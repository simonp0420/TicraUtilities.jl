var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"TICRA. TICRA Tools User’s Manual — TICRA Tools Version 24.0 (TICRA, 2024).\n\n\n\nP.-S. Kildal. Foundations of Antenna Engineering: A Unified Approach for line-of-Sight and Multipath (Artech House, 2015). Note: An updated 2021 version is available for free download at https://www.kildal.se/download-book.\n\n\n\n","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../literate/Tutorial.jl\"","category":"page"},{"location":"Tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"Tutorial/#Reading-and-Plotting-Cut-Files","page":"Tutorial","title":"Reading and Plotting Cut Files","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"We begin by reading in an existing cut file:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using TicraUtilities\n\ncutfile = joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"test.cut\")\ncut = read_cutfile(cutfile)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"We see that read_cutfile returns a Cut object.  The information printed to the REPL shows that the Cut object contains 72 distinct ϕ cuts, each consisting of 361 points in the θ direction, with θ ranging from 0° to 180° in steps of 0.5°. See Cut for documentation on the remaining fields.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Values within the Cut object can be accessed via the functions get_ncomp, get_icut, get_icomp, get_text, get_theta, get_phi, and get_evec.  Some derived quantities can be obtained via the functions power, amplitude_db, and phase_deg.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"This package includes a recipe for plotting a Cut object using the standard Plots package.  So a plot of the cut can be generated very simply:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(cut)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The default result in this case is not very satisfactory.  Note that each trace is automatically labeled according to its polarization (either LHCP or RHCP for this case) and ϕ value, but there are too many ϕ cut labels to fit in the legend.  Let's tweak the plot by just selecting a just a few ϕ values to plot.  We will also normalize the amplitudes according to the peak directivity, and print this peak value in the title of the plot.  Finally, we'll adjust the axes limits and tick locations:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"peakdb = round(maximum_db(cut), digits = 3)\nplot(\n    cut,\n    normalization = :peak,\n    phi = 0:90:315,\n    title = \"Peak = $peakdb dB\",\n    framestyle = :box,\n    xlim = (0, 180),\n    xtick = 0:20:180,\n    ylim = (-60, 0),\n    ytick = -60:5:0,\n)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The plot appearance is now more pleasing. We used the maximum_db function to label the peak field value used for normalizing the plot.  For plotting, most of the keyword arguments that were passed to the plot function above come standard with the Plots package, but phi and normalization are custom keywords introduced by TicraUtilities and are supported only when plotting a Cut object.  The full list of custom keywords available for plotting Cut objects is presented in the table below:","category":"page"},{"location":"Tutorial/#Custom-Plots-Keywords-Specific-to-Cut-Objects","page":"Tutorial","title":"Custom Plots Keywords Specific to Cut Objects","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Keyword Description Legal values\nphi ϕ value(s) to plot Scalar or iterable (defaults to get_phi(cut))\ntheta θ value(s) to plot Scalar or iterable (defaults to get_theta(cut))\npol Polarization to plot :both, :copol, :xpol, 1, or 2 (defaults to :both)\nquantity Quantity to plot :db (the default), :power, :linear, or :phase\nnormalization How to normalize plot :peak or a scalar (defaults to NaN meaning don't normalize)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Values passed in via the phi keyword must all be present in the Cut object. If the values passed via the theta keyword are spaced more finely than those stored in the Cut object, the pattern will be interpolated onto these values using a cubic spline interpolant.  This is demonstrated in the following example plot:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"scatter(\n    cut,\n    label = \"Interpolated In θ\",\n    pol = :copol,\n    normalization = :peak,\n    phi = 0,\n    theta = 0:0.1:5,\n    title = \"Normalized Copol (LHCP), Peak = $peakdb dB\",\n    framestyle = :box,\n    xlim = (0, 5),\n    xtick = 0:0.5:10,\n    ylim=(-0.2, 0.01),\n    ytick = -10:0.05:0)\nscatter!(\n    cut,\n    label = \"No θ Interpolation\",\n    pol = :copol,\n    normalization = :peak,\n    phi = 0,\n    marker = :cross,\n    ms = 6,\n    msw = 2)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The above scatter plot clearly illustrates the results of interpolating in theta.  The example also shows that the default trace labels appearing in the legend can be overridden as desired.","category":"page"},{"location":"Tutorial/#Manipulation-and-Conversion-of-Cut-Objects","page":"Tutorial","title":"Manipulation and Conversion of Cut Objects","text":"","category":"section"},{"location":"Tutorial/#Symmetric-and-Asymmetric-Cuts","page":"Tutorial","title":"Symmetric and Asymmetric Cuts","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"In the previous examples the cut variable contains \"asymmetric\" cuts, each beginning at theta = 0.   A \"symmetric\" cut would cover equal extents in the positive and negative theta directions.  Functions asym2sym and sym2asym can be used to convert between these types of cuts.  Continuing with the asymmetric Cut object from the previous examples:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"scut = asym2sym(cut) # Create a symmetric cut","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the symmetric cuts only extend to 175° in phi, and that each cut covers the range -180^circ le theta le 180^circ.  We plot the new cut below to see this alternative representation of the same data:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    scut,\n    normalization = :peak,\n    phi = 0:45:135,\n    title = \"Normalized Symmetric Cut, Peak = $peakdb dB\",\n    framestyle = :box,\n    xlim = (-180, 180),\n    xtick = -180:30:180,\n    ylim = (-60, 0),\n    ytick = -60:5:0,\n)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"This type of symmetric plot can be useful for spotting pattern asymmetries.","category":"page"},{"location":"Tutorial/#Changing-the-Polarization-Basis-of-a-Cut","page":"Tutorial","title":"Changing the Polarization Basis of a Cut","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The functions convert_cut and convert_cut! can be used to change which of the following pairs of field components","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"E_theta and E_phi\nE_R and E_L (CP or Circular Polarization, right- and left-handed, resp.)\nE_h and E_v (L3 or Ludwig 3, directed along x and y, resp.)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"is used for representing the electric field vector stored in a Cut object. The cut variable used in the previous examples uses CP components, as can be verified using the get_icomp function:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"get_icomp(cut)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The possible values for icomp and their meanings are documented in [1, Sec. 9.7, p. 3306]. Alternatively, one can request help on the Cut type at the Julia REPL. Note: At present, most of the functions in TicraUtilities support only 1, 2, or 3 as possible values for icomp.  In this case, the value is 2, meaning that a circular polarization basis was used.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"If we convert the polarization basis to a Ludwig 3 representation:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"cut_L3 = convert_cut(cut, 3)\npeakdb_L3 = round(maximum_db(cut_L3), digits = 3)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"we see that the peak directivity has been reduced by about 3 dB from its previous value.  Since the boresight radiated field is nearly perfectly circularly polarized, then both L3 components will be approximately equal in magnitude as shown in the following plot:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    cut_L3,\n    normalization = :peak,\n    phi = 0:90:315,\n    title = \"Ludwig 3 Components, Peak = $peakdb_L3 dB\",\n    framestyle = :box,\n    xlim = (0, 180),\n    xtick = 0:20:180,\n    ylim=(-60, 0),\n    ytick = -60:5:0,\n)","category":"page"},{"location":"Tutorial/#Cut-Normalization","page":"Tutorial","title":"Cut Normalization","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Typically, the fields recorded in cut files are normalized so that the total radiated power is 4pi. When this is the case, the field magnitude squared is numerically equal to directivity.  The power integral for a Cut object can be calculated using the power function:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"power(cut) / 4π","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"We see that the power in cut is very close to 4pi.  Although not really necessary in this case, we can modify cut to make the normalization more nearly exact by using the normalize! function:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"normalize!(cut)\npower(cut) / 4π","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"After explicitly normalizing the cut, its radiated power is almost exactly equal to 4pi.","category":"page"},{"location":"Tutorial/#Synthesizing-a-Cut-from-E-and-H-Plane-Patterns","page":"Tutorial","title":"Synthesizing a Cut from E- and H-Plane Patterns","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"A \"BOR₁\" horn [2] is rotationally symmetric and contains only TE₁ₙ and TM₁ₙ waveguide modes in its radiating aperture.  Its radiated far field can therefore be expressed in terms of the E-plane and H-plane (principal plane) patterns it radiates when excited for linear polarization. The eh2bor1cut function synthesizes a Cut object for a BOR₁ antenna from its principal plane patterns, optionally adding in a specified level of crosspol due to an imperfect feed network.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"We begin by reading a cut file for a BOR₁ horn created by TICRA's CHAMP program:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using TicraUtilities\nusing Plots\ncutfile = joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"ticra_hpol_horn.cut\")\ncut = read_cutfile(cutfile)\nprintln(\"Peak =  \", round(maximum_db(cut), digits = 2), \" dB\")","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"cut","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"As seen from the above output, the cut file contains 3 cuts at phi = 0^circ 45^circ, and 90^circ.  Since the cut file was created for horizontal excitation of the horn, the dominant far-field polarization will be Ludwig 3 horizontal, which is stored in the first polarization slot of the cut. It also follows that the E-plane pattern can be extracted from the first (phi = 0^circ) cut and the H-plane pattern from the last (phi = 90^circ) cut:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"fe = get_evec(cut, 1)[:, 1] # ϕ = 0° cut is E-plane for horizontal pol\nfh = get_evec(cut, 1)[:, end] # ϕ = 90° cut is H-plane for horizontal pol\nplot(xlim=(0, 180),\n     xlabel = \"θ (deg)\",\n     ylim = (-60, 30),\n     ylabel = \"Amplitude (dB)\",\n     framestyle = :box,\n     title = \"BOR₁ Horn Principal Plane Patterns\",\n)\ntheta = get_theta(cut)\nplot!(theta, 10 .* log10.(abs2.(fe)), label = \"E-Plane\")\nplot!(theta, 10 .* log10.(abs2.(fh)), label = \"H-Plane\")","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose now that we wish to create a Cut object for this horn, but assuming that it has been excited to generate a predominantly RHCP (right-hand circularly polarized) far field:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"cutrhcp = eh2bor1cut(theta, fe, fh; pol = :rhcp)\nprintln(\"Peak RHCP =  \", round(maximum_db(cutrhcp), digits = 2), \" dBi\")\nprintln(\"(Radiated power)/4π = \",  power(cutrhcp) / 4π)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"cutrhcp","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"As shown above, the maximum field magnitude is about the same as that for the principal plane cuts. And since the cut is properly power-normalized, this value is the maximum partial directivity to RHCP polarization. As stated in the documentation for eh2bor1cut, cutrhcp contains cuts at phi = 0^circ 90^circ 180^circ textand  270^circ.  Plotting the cut at phi = 0^circ:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(cutrhcp,\n     phi = 0,\n     xlim = (0, 90),\n     xtick = 0:10:90,\n     ylim = (-60, 0),\n     framestyle = :box,\n     normalization = :peak,\n     title = \"BOR₁ Horn Excited for RHCP, Normalized Pattern\")","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The plot confirms that the dominant polarization is RHCP.  The maximum crosspol level is about 45 dB below the copol peak.  To simulate the effect of an imperfect feed network that injects crosspol (LHCP) at a level 30 dB below the desired copol, we can use the xpd keyword argument:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"cutrhcp2 = eh2bor1cut(theta, fe, fh; pol = :rhcp, xpd = -30)\nplot(cutrhcp2,\n     phi = 0,\n     xlim = (0, 90),\n     xtick = 0:10:90,\n     ylim = (-60, 0),\n     framestyle = :box,\n     normalization = :peak,\n     title = \"RHCP-Excited BOR₁ Horn, Normalized Pattern\\n-30 dB Xpol Added\\n\")","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected, the boresight crosspol level is now 30 dB below the copol peak, and the crosspol pattern resembles a scaled version of the copol pattern, at least in the vicinity of boresight. Note that the phase of the injected crosspol can be specified using the xpphase keyword argument of eh2bor1cut.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"After creating the Cut object cutrhcp in this manner, it can be saved as a TICRA-compatible cut file using write_cutfile, or it can be converted to a spherical wave expansion using cut2sph, as discussed below in SWE/Cut Conversion.  The resulting SPHQPartition object can be saved as a spherical wave expansion (.sph) file, if desired, using write_sphfile.","category":"page"},{"location":"Tutorial/#Spherical-Wave-Expansions-(SWEs)","page":"Tutorial","title":"Spherical Wave Expansions (SWEs)","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The functions in TicraUtilities can read, write, and manipulate TICRA-compatible spherical wave expansion (.sph) files that employ the newer, more accurate, so-called \"Q\" modes.  To read the contents of such a file, one uses the read_sphfile function.  Below we demonstrate the function's use on a spherical wave expansion file previously generated using GRASP:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using TicraUtilities\nsphfile = joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"center_element_rhcp_excited_q.sph\")\nsph_grasp = read_sphfile(sphfile)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"read_sphfile returns an object of type SPHQPartition, containing the SWE data for a single partition (i.e., frequency) stored in a SWE file.  If the file had consisted of multiple partitions then the returned object would be a vector of such objects. A SPHQPartition object (or a vector of such objects) can be written to a TICRA-compatible file using write_sphfile.  The values stored in the fields of a SPHQPartition object can be retrieved using the functions get_prgtag, get_idstrg, get_nthe, get_nphi, get_nmax, get_mmax, get_qsmns, and get_powerms, along with get_t4 through get_t8.","category":"page"},{"location":"Tutorial/#SWE/Cut-Conversion","page":"Tutorial","title":"SWE/Cut Conversion","text":"","category":"section"},{"location":"Tutorial/#Cut-to-SWE-Conversion","page":"Tutorial","title":"Cut to SWE Conversion","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"A Cut object, a vector of Cut objects, or a cut file can be converted to SWE representation via the cut2sph function. We'll demonstrate this conversion using a measured cut file for a central element of a closely spaced array of planar radiating elements.  Because of strong mutual coupling, the pattern is asymmetrical, as shown in the plot below:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using TicraUtilities\nusing Plots","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"cutfile = joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"center_element_rhcp_excited.cut\")\ncut_meas = read_cutfile(cutfile)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(cut_meas, legend=nothing, framestyle=:box)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that although the cut file contains pattern data out to theta = 180^circ, the values for theta  90^circ are identically zero.  This fact and the large number of samples in the two angular directions make it an interesting and relatively difficult case for spherical wave expansion.  We generate the SWE representation as follows:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"sph_julia = cut2sph(cut_meas)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"On a Core i7-9700 computer running Julia 1.11.0 this conversion takes about 45 msec.  The sph_grasp object read in the previous example was generated by the TICRA GRASP program from the same measured cut file. The maximum difference between the spherical wave \"Q\" coefficients in sph_julia and sph_grasp is","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"maximum(abs, get_qsmns(sph_julia) - get_qsmns(sph_grasp))","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"In the next section we show that both expansions provide similar accuracy in reconstructing the far-field pattern.","category":"page"},{"location":"Tutorial/#SWE-to-Cut-Conversion","page":"Tutorial","title":"SWE to Cut Conversion","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"We can reconstruct the pattern of the previous example by converting the SPHQPartition object sph_julia into a new Cut object  using the sph2cut function:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"cut_julia = sph2cut(sph_julia) # Round trip via Julia: measured cut -> SWE -> reconstructed cut","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"We will compare this Cut object to one from cut file \"center_element_rhcp_excited_q.cut\".  This latter file is also the result of a round-trip conversion cut rightarrow SWE rightarrow cut, beginning with the original measured data cut file, but performed entirely using the TICRA GRASP program. The copol and crosspol comparison is shown below:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"cutfile = joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"center_element_rhcp_excited_q.cut\")\ncut_grasp = read_cutfile(cutfile) # Round trip via GRASP\nrhcp_err_db =  10 * log10(maximum(abs2, get_evec(cut_julia, 1) - get_evec(cut_grasp, 1)))\nlhcp_err_db =  10 * log10(maximum(abs2, get_evec(cut_julia, 2) - get_evec(cut_grasp, 2)))\n(rhcp_err_db, lhcp_err_db) # Compare Julia and GRASP cut reconstructions","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"As shown above, the maximum differences between the reconstructed fields via GRASP and Julia functions are extremely small, on the order of -100 dB.  We can also compare the reconstructed fields versus the original measured cut data:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using LinearAlgebra: norm\njulia_err_db = 20 * log10(maximum(norm, get_evec(cut_julia) - get_evec(cut_meas)))\ngrasp_err_db = 20 * log10(maximum(norm, get_evec(cut_grasp) - get_evec(cut_meas)))\n(julia_err_db, grasp_err_db) # compare each to orig. measured cut","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"GRASP- and Julia-reconstructed patterns show similar agreement with original measured data. Plots of the reconstructed copol and crosspol patterns confirm the similarity of the GRASP and Julia reconstructed pattern data:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(xlim = (0, 180), ylim = (-100, 15), framestyle = :box,\n     title = \"Copol (RHCP) Comparison\")\nplot!(cut_julia, phi = 0, pol = 1, label = \"RHCP sph2cut\")\nplot!(cut_grasp, phi = 0, pol = 1, ls = :dash, label = \"RHCP GRASP\")","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(xlim = (0, 180), ylim = (-100, 15), framestyle = :box,\n     title = \"Crosspol (LHCP) Comparison\")\nplot!(cut_julia, phi = 0, pol = 2, label = \"LHCP sph2cut\")\nplot!(cut_grasp, phi = 0, pol = 2, ls = :dash, label = \"LHCP GRASP\")","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The rapid dropoff at phi = 90^circ occurs because the original pattern data from which the spherical wave coefficients were derived was only nonzero in the forward hemisphere of the antenna. Finite amplitudes in the reconstructed patterns for theta  90^circ are due to the discontinuity in the fields at theta = 90^circ, which would require an infinite number of modes to reproduce exactly.","category":"page"},{"location":"Tutorial/#Tabulated-Electrical-Properties-(TEP)-Files","page":"Tutorial","title":"Tabulated Electrical Properties (TEP) Files","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"There are two styles of TEP files:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The original TEP file introduced by GRASP8, referred to as a \"scattering surface TEP file.\"\nThe new format introduced by the QUPES program, referrred to as a \"periodic unit cell TEP file.\"","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"TicraUtilities provides functions to read and write either style of TEP file, and to convert between the two.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"TEP files can be read using the read_tepfile function, and written to disk using the write_tepfile function.","category":"page"},{"location":"Tutorial/#Scattering-Surface-TEP-Files","page":"Tutorial","title":"Scattering Surface TEP Files","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Here is an example of reading a scattering surface TEP file:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using TicraUtilities\ntepfile = joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"tepscatter1freq.tep\")\ntep_s1 = read_tepfile(tepfile)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"For this TEP file that contains data for a single frequency, a single object of type TEPscatter is returned. For a multi-frequency TEP file, a vector of TEPscatter objects would have been returned.  As the REPL printout shows, the object contains fields title, theta, phi, sff, sfr, srf, and srr.  They can be accessed via the functions get_title, get_theta, get_phi, get_sff, get_sfr, get_srf, and get_srr, respectively.  The last four fields are multidimensional arrays containing complex scattering coefficients, sampled on a regular grid in the theta-phi plane. The arrays all have dimensions 2×2×nt×np, where nt = length(get_theta(tep_s1)) is the number of θ values and np = length(get_phi(tep_s1)) is the number of ϕ values. sff and srr are reflection coefficients for front and rear surface incidence, respectively.  srf and sfr are transmission coefficients for front and rear surface incidence, respectively.  For any of these, fixing the last two indices (i.e., choosing particular values of θ and ϕ) while allowing the first two indices to vary results in a 2×2 matrix.  For the reflection coefficient arrays the 2×2 matrices contain beginbmatrix R_theta theta  R_theta phi  R_phi theta  R_phi phi endbmatrix, while for the two transmission coefficient arrays, they contain beginbmatrix T_theta theta  T_theta phi  T_phi theta  T_phi phi endbmatrix.","category":"page"},{"location":"Tutorial/#Periodic-Unit-Cell-TEP-Files","page":"Tutorial","title":"Periodic Unit Cell TEP Files","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"TicraUtilities currently cannot accommodate TEP files that contain sweeps of geometrical parameters. I.e., the file may sweep only incidence angles and frequencies.  Here is an example of reading a periodic unit cell TEP file:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using TicraUtilities\ntepfile = joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"ticra_tools_twister.tep\")\ntep_p1 = read_tepfile(tepfile)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"This call returns a single, multifrequency TEPperiodic object. As the REPL printout shows, the object contains fields name, class, theta, phi, freqs, sff, sfr, srf, and srr.  The values stored in these fields may be accessed using the functions get_name, get_class, get_theta, get_phi, get_freqs, get_sff, get_sfr, get_srf, and get_srr, respectively. The last four fields are multidimensional arrays containing complex scattering coefficients, sampled on a regular grid in the theta-phi-frequency space. The arrays all have dimensions 2×2×nt×np×nf, where nt = length(get_theta(tep_p1)) is the number of θ values, np = length(get_phi(tep_p1)) is the number of ϕ values, and nf = length(get_freqs(tep_p1)) is the number of frequencies. sff and srr are reflection coefficients for front and rear surface incidence, respectively.  srf and sfr are transmission coefficients for front and rear surface incidence, respectively.  For any of these, fixing the last three indices (i.e., choosing particular values of θ, ϕ, and frequency) while allowing the first two indices to vary results in a 2×2 matrix.  For the reflection coefficient arrays the 2×2 matrices contain beginbmatrix R_textTE textTE  R_textTE textTM  R_textTM textTE  R_textTM textTM endbmatrix, while for the two transmission coefficient arrays, they contain beginbmatrix T_textTE textTE  T_textTE textTM  T_textTM textTE  T_textTM textTM endbmatrix.","category":"page"},{"location":"Tutorial/#TEPperiodic-\\leftrightarrow-TEPscatter-Conversion","page":"Tutorial","title":"TEPperiodic leftrightarrow TEPscatter Conversion","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The function tepp2s will convert an object of type TEPperiodic to an object (or vector of objects in the case of multiple frequencies) of type TEPscatter.  The function  teps2p provides conversion in the opposite direction.  As an example, we convert tep_p1 from the previous example to TEPscatter format:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful: @u_str\nd = 15u\"mm\" # Distance separating unit cell front and rear surfaces\ntep_s2 = tepp2s(tep_p1, d)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Since tep_p1 contained two frequencies, tep_s2 is a vector of two TEPscatter objects.  It was necessary to supply the distance d as an argument to tepp2s because it is needed to compute the phase correction involved in the conversion.  Similarly, when converting in the other direction, both the distance and frequency (or frequencies) must be provided, because both are needed to compute the phase correction but neither is included in a scattering surface-type TEP file/object.  These can be obtained from tep_p1 for this example:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"freqs = get_freqs(tep_p1)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we have the necessary inputs to convert tep_s2 back to TEPperiodic format:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"tep_p3 = teps2p(tep_s2, d, freqs)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"We can check whether the scattering coefficients in tep_p3 that resulted from round-trip conversion are exactly equal to those of the original tep_p1:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"(get_sff(tep_p3) == get_sff(tep_p1), get_sfr(tep_p3) == get_sfr(tep_p1),\n get_srf(tep_p3) == get_srf(tep_p1), get_srr(tep_p3) == get_srr(tep_p1))","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Only the sff (front surface reflection coefficients) entries are exactly equal.  This is because only front surface reflection coefficients do not require phase corrections during the conversions.  There is a slight floating point error incurred when computing the phase corrections, as shown below:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"maximum(abs, get_sfr(tep_p1) - get_sfr(tep_p3))","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Instead of testing for exact equality, we can check for approximate equality:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"(get_sff(tep_p3) ≈ get_sff(tep_p1), get_sfr(tep_p3) ≈ get_sfr(tep_p1),\n get_srf(tep_p3) ≈ get_srf(tep_p1), get_srr(tep_p3) ≈ get_srr(tep_p1))","category":"page"},{"location":"Tutorial/#Surface-Files","page":"Tutorial","title":"Surface Files","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"TICRA-compatible surface (.sfc) files can be read using the read_surface function, and written to disk using the write_surface function.  The results of reading a surface file are stored in an object of type TicraUtilities.Surface as in the following example:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"sfcfile = joinpath(joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"parent_parabola.sfc\"))\nsfc = read_surface(sfcfile)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Values within the Surface object can be accessed via the functions get_x, get_y, get_z, and get_text.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The + and - operators have been overloaded to work on surfaces, resulting in new surfaces whose z values are the sum or difference of those of the operand surfaces:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"sfc2 = sfc + sfc\nget_z(sfc2) ≈ 2 * get_z(sfc)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"sfc3 = sfc - sfc\nmaximum(abs, get_z(sfc3))","category":"page"},{"location":"Tutorial/#Array-Excitation-Files","page":"Tutorial","title":"Array Excitation Files","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"TICRA-compatible array excitation (.exi) files can be read using the `read_exifile function, and written to disk using the write_exifile function.  The results of reading an array excitation file are stored in an object of type Exi as in the following example:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"exifile = joinpath(joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"beam_A14R.exi\"))\nexi = read_exifile(exifile)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Values within the Exi object can be accessed via the functions get_header, get_ampdb (or amplitude_db), get_phsdeg (or phase_deg), and get_ids. For example:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"get_ampdb(exi)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"get_phsdeg(exi)","category":"page"},{"location":"Tutorial/#Optimization-Station-Files","page":"Tutorial","title":"Optimization Station Files","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"TICRA-compatible optimization station (.sta) files, also known as \"Field Directions\" file, can be read using the `read_stationfile function, and written to disk using the write_stationfile function.  The results of reading a station file are stored in a vector of objects of type Station as in the following example:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"stationfile = joinpath(joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"scenario2_coverage.sta\"))\nstations = read_stationfile(stationfile)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Values within a Station object can be accessed via the functions get_npoint, get_u, get_v,  get_goal,  get_weight,  get_ipol,  get_rot,  get_att,  and get_id.","category":"page"},{"location":"Tutorial/#TICRA-Object-Repository-(TOR)-Files","page":"Tutorial","title":"TICRA Object Repository (TOR) Files","text":"","category":"section"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"TOR files can be read and written using the functions read_torfile and write_torfile, respectively.  Here is an example of reading a TOR file:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"torfile = joinpath(dirname(pathof(TicraUtilities)), \"..\", \"test\", \"tabulated_rim_tor_file.tor\")\ntorobjs = read_torfile(torfile)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"read_torfile returns a vector of TorObj objects.  Here is the first element of this vector:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"torobj = torobjs[1]","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The name and TICRA type of the object are shown, followed by propertynames and their corresponding values. These can be extracted from the TorObj object using functions get_name, get_objtype, get_propname, and get_propval. For example:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"get_name(torobj)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"get_objtype(torobj)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"get_propname(torobj)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"get_propval(torobj)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The parse_tor_struct function can be used to parse the TICRA struct objects listed in the final two elements of get_propval(torobj):","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"struct1 = parse_tor_struct(get_propval(torobj)[end-1])","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"struct2 = parse_tor_struct(get_propval(torobj)[end])","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"struct1 and struct2 are NamedTuples. Their field names and values can be obtained using Julia's keys and values functions:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"keys(struct2)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"values(struct2)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the parsed values of numeric quantities with associated units (such as \"x\" and \"y\" in the above example) are converted to Unitful quantities.   For example:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"struct2.x","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"The purely numeric portion and the units can be extracted using functions supplied by Unitful:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"using Unitful: unit, ustrip\nunit(struct2.x)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"ustrip(struct2.x)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, both can be converted to strings, if desired:","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"string(struct2.x)","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"Of the units that can occur in a TOR file, \"in\" is the only one which is modified when translated to Julia. In the Julia representation, \"inch\" is used instead of \"in\" to avoid confusion with the built-in Julia function in.","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"Tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Contents/","page":"Contents","title":"Contents","text":"EditURL = \"../literate/Contents.jl\"","category":"page"},{"location":"Contents/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"Contents/","page":"Contents","title":"Contents","text":"Depth = 4\nPages = [\"index.md\", \"Tutorial.md\", \"autodocs.md\", \"references.md\"]","category":"page"},{"location":"Contents/","page":"Contents","title":"Contents","text":"","category":"page"},{"location":"Contents/","page":"Contents","title":"Contents","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"EditURL = \"../literate/index.jl\"","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TicraUtilities is a package to facilitate working with Ticra-compatible files and data objects in the Julia language. TICRA is a Danish company specializing in antenna analysis and synthesis software. Their products for analysis and design of reflector antennas (and associated feed structures) are widely regarded as standards in the antenna community.  As a result, the file formats defined and used by TICRA software [1] have also become de facto industry standards.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides utilities in the Julia programming language for","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Reading, writing, and plotting Ticra-compatible cut (.cut) files.\nReading, parsing, and writing Ticra Object Repository (.tor) files.\nConverting cut files to and from spherical wave expansion (.sph) files.\nReading and writing so-called \"station\" (.stn) files.\nReading and writing array excitation (.exi) files.\nReading and writing \"surface\" (.sfc) files.\nAnd more...","category":"page"},{"location":"#Package-Installation","page":"Introduction","title":"Package Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"You can obtain TicraUtilities using Julia's Pkg REPL-mode (hitting ] as the first character of the command prompt):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(v1.10) pkg> add TicraUtilities","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or with using Pkg; Pkg.add(\"TicraUtilities\").","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"EditURL = \"../literate/autodocs.jl\"","category":"page"},{"location":"autodocs/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"autodocs/#Publicly-Exported-Functions","page":"API Reference","title":"Publicly Exported Functions","text":"","category":"section"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"complex(::Exi)","category":"page"},{"location":"autodocs/#Base.complex-Tuple{Exi}","page":"API Reference","title":"Base.complex","text":"complex(t::Exi)\n\nReturn a vector of complex excitation amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"isapprox(::Cut, ::Cut)","category":"page"},{"location":"autodocs/#Base.isapprox-Tuple{Cut, Cut}","page":"API Reference","title":"Base.isapprox","text":"isapprox(c1::Cut, c2::Cut; kwargs...) -> tf::Bool\n\nCompare two Cut objects for approximate equality.\n\nCompares most fields for perfect equality except text and evec. The text fields are not compared at all, and the evec fields  (Matrix types) are compared for approximate equality using isapprox.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"maximum(::Cut)","category":"page"},{"location":"autodocs/#Base.maximum-Tuple{Cut}","page":"API Reference","title":"Base.maximum","text":"maximum(cut::Cut) -> maxE\n\nReturn the maximum amplitude for any polarization component stored in the Cut object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"+(::TicraUtilities.Surface, ::TicraUtilities.Surface)","category":"page"},{"location":"autodocs/#Base.:+-Tuple{Surface, Surface}","page":"API Reference","title":"Base.:+","text":"+(s1::Surface, s2::Surface)\n\nReturn a new Surface whose z values are the sum of those of s1 and s2. s1 and s2 must have identical x and y fields.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"-(::TicraUtilities.Surface, ::TicraUtilities.Surface)","category":"page"},{"location":"autodocs/#Base.:--Tuple{Surface, Surface}","page":"API Reference","title":"Base.:-","text":"-(s1::Surface, s2::Surface)\n\nReturn a new Surface whose z values are the difference of those of s1 and s2. s1 and s2 must have identical x and y fields.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"Modules = [TicraUtilities]\nOrder   = [:function]\nPrivate = false","category":"page"},{"location":"autodocs/#TicraUtilities.amplitude_db","page":"API Reference","title":"TicraUtilities.amplitude_db","text":"amplitude_db(c::Cut, ipol::Int)\namplitude_db(c::Cut, polsymb::Symbol = :copol)\namplitude_db(c::Cut, polstr::String = \"copol\")\n\nReturn a matrix of amplitudes in dB for some choice of polarization in the cut. Legal values for ipol are 1, 2, or 3, the latter only being legal if there are three polarization components present in the cut.  Legal values for polstr are \"copol\" (the default) and \"xpol\".  Capitalization is not significant. Legal values for polsymb are :copol and :xpol.  Again, capitalization is not significant.  Copol is defined as the polarization with maximum amplitude at θ = ϕ = 0.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#TicraUtilities.amplitude_db-Tuple{Exi}","page":"API Reference","title":"TicraUtilities.amplitude_db","text":"amplitude_db(t::Exi)\n\nReturn a vector of excitation amplitudes in dB\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.asym2sym-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.asym2sym","text":"asym2sym(cut::Cut) -> cut2\n\nConvert an asymmetrical (in θ) Cut to a new symmetrical Cut.  An asymmetrical cut begins at θ = 0, while a symmetrical cut covers equal extents of negative and  positive angles.  If the input cut is already symmetrical, then return a copy of  this input as the output.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.convert_cut!-Union{Tuple{N}, Tuple{Tcp}, Tuple{Tct}, Tuple{Cut{Tct, Tcp, N}, Integer}} where {Tct, Tcp, N}","page":"API Reference","title":"TicraUtilities.convert_cut!","text":"convert_cut!(cut::Cut, icomp::Integer)\n\nConvert cut to a new polarization basis determined by icomp.  Legal values  for icomp and their meanings:\n\n1 => Eθ and Eϕ\n2 => ERHCP and ELHCP\n3 => Eh and Ev (Ludwig 3 co and cx)\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.convert_cut-Union{Tuple{N}, Tuple{Tc}, Tuple{Cut{Tc, N}, Any}} where {Tc, N}","page":"API Reference","title":"TicraUtilities.convert_cut","text":"cut2 = convert_cut(cut::Cut, icomp::Integer)\n\nMake a copy of cut and convert it to a new polarization basis determined by icomp.  Legal values  for icomp and their meanings:\n\n1 => Eθ and Eϕ\n2 => ERHCP and ELHCP\n3 => Eh and Ev (Ludwig 3 co and cx)\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.cut2sph-Tuple{AbstractString}","page":"API Reference","title":"TicraUtilities.cut2sph","text":"cut2sph(cut::Cut; keywords...) -> sph::SPHQPartition\n\ncut2sph(cuts::AbstractVector{Cut}; keywords...) -> sphs::Vector{SPHQPartition}\n\ncut2sph(cutfile::AbstractString; kwargs...) -> s::SPHQPartition\n\nConvert a Cut object to a SPHQPartition using recursive FFT/IFFT methods from the Hansen 1988 book \"Spherical Near-Field Antenna Measurements.\n\nThe single positional input argument can be either a string containing the name  of a Ticra-compatible, spherical polar cut file, or the returned value of type Cut  (or a vector of Cut objects) that results from reading such a file with read_cutfile.   The input cut object must be \"asymmetrical\", i.e. each ϕ cut must start at θ = 0.  A symmetrical cut can be converted to an asymmetrical cut using sym2asym.  The output of this function can be passed to write_sphfile to create a Ticra-compatible file of Q-type  spherical wave coefficients.\n\nIf the input cuts extend in θ only to θ₀ < 180°, then it will be assumed that the fields are identically zero for θ₀ < θ ≤ 180°.\n\nKeyword Arguments (and their default values)\n\nmmax=1000: An upper limit for the m (azimuthal) mode index to be included. The actual limit will be set to min(Nϕ÷2, mmax) for odd Nϕ, and min(Nϕ÷2-1, mmax) for even Nϕ, where Nϕ is the number of ϕ = constant polar cuts in the cut object.\nnmax=1000: An upper limit for the n (polar) mode index to be included. The actual limit will be the lesser of nmax and Nθ-1 where Nθ is the number of  θ values included in each ϕ = constant polar cut.\npwrtol=0.0: The power tolerance.  Spherical modes are included until the excluded modes' power is less than pwrtol times the total modal power.  A zero or negative value precludes removal of any modes.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.eh2bor1cut-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"API Reference","title":"TicraUtilities.eh2bor1cut","text":"eh2bor1cut(theta, fe, fh; kwargs...) -> cut::Cut\n\nCreate a Cut object for a \"BOR1\" horn from its E-plane and H-plane patterns.\n\nA \"BOR₁\" horn is circularly symmetric and contains only TE₁ₙ and TM₁ₙ waveguide modes in its  radiating aperture.  It's radiated far field can therefore be expressed in terms of the E-plane and H-plane patterns it radiates when excited for linear polarization.\n\nPositional Input Arguments\n\ntheta: A vector or range (an AbstractVector) of θ values (in degrees) at which the cut  pattern should be evaluated. The first element of theta must be 0, and the entries must  be equally spaced, as in a range object.\nfe, fh: The E-plane and H-plane patterns, resp.  These are either both AbstractVectors of the  same length as theta, or both functions which take a single input θ (in degrees) and return the  respective patterns evaluated at that angle.\n\nKeyword Arguments\n\npol: Defines the manner in which the horn is assumed to be excited, and the polarization basis  selected for use in the output Cut.  pol is a String or Symbol taking one of the values (capitalization is not significant):\n\"l3v\" or :l3v: (the default value) The horn is excited for \"vertical\" (y-directed) linear polarization  and the far field is expressed as Ludwig-3 components.  \n\"l3h\" or :l3h: The horn is excited for \"horizontal\" (x-directed) linear polarization and the far field is expressed as Ludwig-3 components.\n\"rhcp\" or :rhcp: The horn is excited for RHCP (right-hand circular polarization) and the far field is expressed as RHCP and LHCP components.\n\"lhcp\" or :lhcp: The horn is excited for LHCP (left-hand circular polarization) and the far field is expressed as RHCP and LHCP components.\nIf linear (circular) polarization is requested, then the output Cut object will contain eight (four) cuts, spaced every 45° (90°). \nxpd: The crosspol level in dB < 0. Defaults to -Inf (negative infinity).  If finite, then in addition to the specified polarization, a crosspolarized contribution will be added to the cut, as if the horn is fed by an imperfect feed network with the specified crosspol level.\nxpphase: The phase (in degrees) of the crosspol contribution whose amplitude is specified by xpd.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_ampdb-Tuple{Exi}","page":"API Reference","title":"TicraUtilities.get_ampdb","text":"get_ampdb(t::Exi)\n\nReturn a vector of excitation amplitudes in dB\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_att-Tuple{Station}","page":"API Reference","title":"TicraUtilities.get_att","text":"get_att(s::Station)\n\nReturn att, the vector of attenuation values wrt nadir in dB.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_class-Tuple{TEPperiodic}","page":"API Reference","title":"TicraUtilities.get_class","text":"get_class(tep::TEPperiodic)\n\nReturn the class name string for the TEP object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_evec-Tuple{Cut, Integer}","page":"API Reference","title":"TicraUtilities.get_evec","text":"get_evec(c::Cut, ipol::Integer)\n\nReturn the ntheta × nphi matrix of complex numbers stored in polarization slot ipol of  the cut. ipol must be positive and less than or equal to get_ncomp(cut).\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_evec-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.get_evec","text":"get_evec(c::Cut)\n\nReturn the ntheta × nphi matrix of complex field vectors stored in the cut. Each element of the returned matrix will be either a 2-vector or 3-vector, depending on the number of field components stored in the cut.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_freqs-Tuple{TEPperiodic}","page":"API Reference","title":"TicraUtilities.get_freqs","text":"get_freqs(tep::TEPperiodic)\n\nReturn the vector of frequencies.  The elements of the vector will be Unitful quantities, each  of which may have different frequency units.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_goal-Tuple{Station}","page":"API Reference","title":"TicraUtilities.get_goal","text":"get_goal(s::Station)\n\nReturn goal, the vector of optimization goals in dB.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_header-Tuple{Exi}","page":"API Reference","title":"TicraUtilities.get_header","text":"get_header(t::Exi)\n\nReturn a vector of excitation header strings.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_icomp-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.get_icomp","text":"get_icomp(c::Cut)\n\nReturn icomp, polarization parameter. 1 for Eθ and Eφ, 2 for RHCP and LHCP, 3 for h and v (Ludwig 3).\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_icut-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.get_icut","text":"get_icut(c::Cut)\n\nReturn icut, the control parameter of the cut. 1 for a polar cut, 2 for a conical cut. TicraUtilities currently accommodates only icut == 1, wherein each cut is for a constant ϕ value.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_id-Tuple{Station}","page":"API Reference","title":"TicraUtilities.get_id","text":"get_id(s::Station)\n\nReturn id, the vector of station ID strings.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_ids-Tuple{Exi}","page":"API Reference","title":"TicraUtilities.get_ids","text":"get_ids(t::Exi)\n\nReturn a vector of excitation ID strings.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_idstrg-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_idstrg","text":"get_idstrg(s::SPHQPartition)\n\nReturn the idstrg string of s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_ipol-Tuple{Station}","page":"API Reference","title":"TicraUtilities.get_ipol","text":"get_ipol(s::Station)\n\nReturn ipol, the vector of station polarization codes.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_mmax-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_mmax","text":"get_mmax(s::SPHQPartition)\n\nReturn the integer mmax (maximum m index) associated with s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_name-Tuple{TEPperiodic}","page":"API Reference","title":"TicraUtilities.get_name","text":"get_name(tep::TEPperiodic)\n\nReturn the object name string for the TEP object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_name-Tuple{TorObj}","page":"API Reference","title":"TicraUtilities.get_name","text":"get_name(obj::TorObj) -> name::String\n\nReturn the object name.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_ncomp-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.get_ncomp","text":"get_ncomp(c::Cut)\n\nReturn ncomp, the number of polarization components stored in the cut.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_nmax-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_nmax","text":"get_nmax(s::SPHQPartition)\n\nReturn the integer nmax (maximum n index) associated with s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_nphi-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_nphi","text":"get_nphi(s::SPHQPartition)\n\nReturn the integer nphi (number of phi points) associated with s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_npoint-Tuple{Station}","page":"API Reference","title":"TicraUtilities.get_npoint","text":"get_npoint(s::Station)\n\nReturn npoint, the number of stations.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_nthe-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_nthe","text":"get_nthe(s::SPHQPartition)\n\nReturn the integer nthe (number of theta points) associated with s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_objtype-Tuple{TorObj}","page":"API Reference","title":"TicraUtilities.get_objtype","text":"get_objtype(obj::TorObj) -> objtype::String\n\nReturn the Ticra object type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_phi-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.get_phi","text":"get_phi(c::Cut)\n\nReturn the phi values (degrees) stored in the cut. The returned value will be  some type of AbstractRange object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_phi-Tuple{TicraUtilities.TEP}","page":"API Reference","title":"TicraUtilities.get_phi","text":"get_phi(tep::TEP)\n\nReturn the phi values (degrees) stored in the TEP object. The returned value will be  some type of AbstractRange object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_phsdeg-Tuple{Exi}","page":"API Reference","title":"TicraUtilities.get_phsdeg","text":"get_phsdeg(t::Exi)\n\nReturn a vector of excitation phases in degrees.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_powerms-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_powerms","text":"get_powerms(s::SPHQPartition)\n\nReturn the offset vector powerms. The vector has axes (0:mmax) (i.e. it can be indexed  with integers m ranging from 0 to mmax) and its mth element contains the total power (one-half the sum of the magnitude squared) of all modes with ±m as the m index.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_prgtag-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_prgtag","text":"get_prgtag(s::SPHQPartition)\n\nReturn the prgtag string of s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_propname-Tuple{TorObj}","page":"API Reference","title":"TicraUtilities.get_propname","text":"get_propname(obj::TorObj) -> propname::Vector{String}\n\nReturn the vector of object property names.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_propval-Tuple{TorObj}","page":"API Reference","title":"TicraUtilities.get_propval","text":"get_propval(obj::TorObj) -> propval::Vector{String}\n\nReturn the vector of object property values.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_qsmns-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_qsmns","text":"get_qsmns(s::SPHQPartition)\n\nReturn the offset array qsmns::OffsetArray{ComplexF64, 3} that contains the  Q coefficients, assuming exp(jωt) time variation and using the Ticra normalization  convention.  The array has axes (1:2, -mmax:mmax, 1:nmax), meaning  that some of  the entries (those with n < abs(m)) are always zero.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_rot-Tuple{Station}","page":"API Reference","title":"TicraUtilities.get_rot","text":"get_rot(s::Station)\n\nReturn rot, the vector of station polarization rotation angles in degrees.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_sff-Tuple{TicraUtilities.TEP}","page":"API Reference","title":"TicraUtilities.get_sff","text":"get_sff(tep::TEP)\n\nReturn the reflection array for front incidence. The array has size (2, 2, length(theta), length(phi) for a TEPscatter object and (2, 2, length(theta), length(phi), length(freqs)) for a TEPperiodic object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_sfr-Tuple{TicraUtilities.TEP}","page":"API Reference","title":"TicraUtilities.get_sfr","text":"get_sfr(tep::TEP)\n\nReturn the transmission array for rear incidence. The array has size (2, 2, length(theta), length(phi) for a TEPscatter object and (2, 2, length(theta), length(phi), length(freqs)) for a TEPperiodic object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_srf-Tuple{TicraUtilities.TEP}","page":"API Reference","title":"TicraUtilities.get_srf","text":"get_srf(tep::TEP)\n\nReturn the transmission array for front incidence. The array has size (2, 2, length(theta), length(phi) for a TEPscatter object and (2, 2, length(theta), length(phi), length(freqs)) for a TEPperiodic object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_srr-Tuple{TicraUtilities.TEP}","page":"API Reference","title":"TicraUtilities.get_srr","text":"get_srr(tep::TEP)\n\nReturn the reflection array for rear incidence. The array has size (2, 2, length(theta), length(phi) for a TEPscatter object and (2, 2, length(theta), length(phi), length(freqs)) for a TEPperiodic object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_t4-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_t4","text":"get_t4(s::SPHQPartition)\n\nReturn the string t4 associated with s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_t5-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_t5","text":"get_t5(s::SPHQPartition)\n\nReturn the string t5 associated with s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_t6-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_t6","text":"get_t6(s::SPHQPartition)\n\nReturn the string t6 associated with s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_t7-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_t7","text":"get_t7(s::SPHQPartition)\n\nReturn the string t7 associated with s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_t8-Tuple{SPHQPartition}","page":"API Reference","title":"TicraUtilities.get_t8","text":"get_t8(s::SPHQPartition)\n\nReturn the string t8 associated with s.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_text-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.get_text","text":"get_text(c::Cut)\n\nReturn a vector of strings containing the cut identification text.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_text-Tuple{Surface}","page":"API Reference","title":"TicraUtilities.get_text","text":"get_text(c::Surface) -> t::String\n\nReturn the text string associated with surface c.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_theta-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.get_theta","text":"get_theta(c::Cut)\n\nReturn the theta values (in degrees) stored in the cut.  The returned value will be  some type of AbstractRange object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_theta-Tuple{TicraUtilities.TEP}","page":"API Reference","title":"TicraUtilities.get_theta","text":"get_theta(tep::TEP)\n\nReturn the theta values (degrees) stored in the TEP object. The returned value will be  some type of AbstractRange object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_title-Tuple{TEPscatter}","page":"API Reference","title":"TicraUtilities.get_title","text":"get_title(tep::TEPscatter)\n\nReturn the title string for the TEP object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_u-Tuple{Station}","page":"API Reference","title":"TicraUtilities.get_u","text":"get_u(s::Station)\n\nReturn u, the vector of unitless station direction cosines along x.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_v-Tuple{Station}","page":"API Reference","title":"TicraUtilities.get_v","text":"get_v(s::Station)\n\nReturn v, the vector of unitless station direction cosines along y.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_weight-Tuple{Station}","page":"API Reference","title":"TicraUtilities.get_weight","text":"get_weight(s::Station)\n\nReturn weight, the vector of station optimization weights.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_x-Tuple{Surface}","page":"API Reference","title":"TicraUtilities.get_x","text":"get_x(c::Surface) -> x::AbstractRange\n\nReturn the range of x values for surface c.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_y-Tuple{Surface}","page":"API Reference","title":"TicraUtilities.get_y","text":"get_y(c::Surface) -> y::AbstractRange\n\nReturn the range of y values for surface c.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.get_z-Tuple{Surface}","page":"API Reference","title":"TicraUtilities.get_z","text":"get_z(c::Surface) -> z::Matrix{Float64}\n\nReturn the matrix of z values for surface c. z[i,j] is the z value sampled at (x y) coordinates (x[i], y[j]).\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.issym-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.issym","text":"issym(cut::Cut) -> tf::Bool\n\nCheck if a cut has a symmetrical range in theta that includes zero.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.maximum_db-Tuple{Cut}","page":"API Reference","title":"TicraUtilities.maximum_db","text":"maximum_db(cut::Cut)\n\nReturn the maximum amplitude in dB for any polarization component stored in the Cut object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.normalize!","page":"API Reference","title":"TicraUtilities.normalize!","text":"normalize!(cut::Cut, totpower=4π)\n\nNormalize a Cut object so it's total power is totpower (which defaults to 4π). The default value results in field magnitude squared being numerically equal to directivity.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#TicraUtilities.parse_tor_struct-Tuple{AbstractString}","page":"API Reference","title":"TicraUtilities.parse_tor_struct","text":"parse_tor_struct(s::AbstractString) -> t::NamedTuple\n\nThe input string is an entry in a TorObj propval field, consisting of, e.g., \"struct(status: automatic, x: 1 in, y:23.4  mm)\".  This function parses out the Ticra struct and returns a NamedTuple t whose propertynames are the Ticra struct field names.  The values of t are either strings or Unitful quantities.  In the example given, t.status == \"automatic\", t.x == 1.0u\"inch\", and  t.y == 23.4u\"mm\".\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.phase_deg","page":"API Reference","title":"TicraUtilities.phase_deg","text":"phase_deg(c::Cut, ipol::Int)\nphase_deg(c::Cut, polsymb::Symbol)\nphase_deg(c::Cut, polstr::String = \"copol\")\n\nReturn a matrix of phases in degrees for some choice of polarization in the cut. Legal values for ipol are 1, 2, or 3.  Legal values for polstr are \"copol\" (the default) and \"xpol\" (capitalization is not significant).  Legal values of polsymb are :copol and :xpol.  Again, capitalization is not significant. The returned value is a Matrix{Float64} with length(get_theta(cut)) rows and length(get_phi(cut)) columns.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#TicraUtilities.phase_deg-Tuple{Exi}","page":"API Reference","title":"TicraUtilities.phase_deg","text":"phase_deg(t::Exi)\n\nReturn a vector of excitation phases in degrees.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.phscen","page":"API Reference","title":"TicraUtilities.phscen","text":"(x,y,z0,z90) = phscen(cut, fghz=11.80285268; min_dropoff=-10)\n\nEstimate phase center for a cut file or Cut object using NSI least-squares algorithm.\n\nThe four outputs are estimates of the location of the phase center relative to the origin used in recording the data in the cut.  If fghz is passed in as  an argument, the values will be expressed in units of inches.  Otherwise the  lengths will be normalized to wavelengths. Note that z0 and z90 are the  phi = 0ᵒ and phi = 90ᵒ plane estimates of the phase center location.   In determining the phase center locations, only field values with magnitudes in dB greater than min_dropoff relative to the peak field are considered.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#TicraUtilities.power","page":"API Reference","title":"TicraUtilities.power","text":"power(cut::Cut, θmax=180)\n\nCompute the total radiated power in a Cut object.  If only a single phi value is included in the cut, then assume no azimuthal variation. The integration in the θ direction will be computed over the limits from 0 to min(θmax, last(get_theta(cut))). θmax should be specified in degrees.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#TicraUtilities.read_cutfile-Tuple{AbstractString}","page":"API Reference","title":"TicraUtilities.read_cutfile","text":"read_cutfile(fname) -> Vector{Cut}\n\nRead data from a possibly multi-frequency Ticra-compatible cut file.  \n\nReturn a single Cut struct or a vector Cut structs.  Each element of the returned vector  corresponds to a particular operating frequency partition in the file.  If there  is only a single partition in the file, then instead of returning a 1-element vector, the single object of type Cut is returned as a scalar.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.read_exifile-Tuple{AbstractString}","page":"API Reference","title":"TicraUtilities.read_exifile","text":"read_exifile(filename::AbstractString)\n\nReads contents of a Ticra-compatible excitation file and returns a Exi object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.read_sphfile-Tuple{AbstractString}","page":"API Reference","title":"TicraUtilities.read_sphfile","text":"read_sphfile(fname) -> Vector{SPHQPartition}\n\nRead the SPH coefficients from a Q-type spherical wave expansion file. \n\nIn the process of reading the data, the coefficients in the file (Q′) are conjugated and then multiplied by the factor √(8π) to achieve Ticra-standard normalization.   Each element of the returned vector corresponds to a particular operating frequency partition in the file.  If there is only a single partition in the file, then instead of returning a 1-element vector, the single element of type SPHQPartition is returned as a scalar.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.read_stationfile-Tuple{Any}","page":"API Reference","title":"TicraUtilities.read_stationfile","text":"read_stationfile(stationfile) -> Vector{Station}\n\nRead the contents of a Ticra optimization station file. The returned value is a vector of length npart, where npart is the number of partitions in the file.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.read_surface-Tuple{AbstractString}","page":"API Reference","title":"TicraUtilities.read_surface","text":"read_surface(fname::AbstractString) -> s::Surface\n\nRead a Ticra-compatible surface file and return a Surface object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.read_tepfile-Tuple{AbstractString}","page":"API Reference","title":"TicraUtilities.read_tepfile","text":"read_tepfile(filename::AbstractString)\n\nRead a TICRA-compatible \"Tabulated Electrical Properties\" (TEP) file.  The file may be in either the original format (scattering surface) originated by GRASP8 or the newer format for periodic unit cells created by the QUPES program.  The return value depends on the type of TEP file encountered:\n\nOld-style scattering surface: For a TEP file containing data for a single frequency, the return value will be a scalar object of type TEPscatter.  If the file contains data for multiple frequencies, the return value will be an object of type Vector{TEPscatter}, with one element for each frequency.\nNew-style periodic unit cell: The return value will be an object of type TEPperiodic.  Note that the file may not contain swept geometrical parameters.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.read_torfile-Tuple{AbstractString}","page":"API Reference","title":"TicraUtilities.read_torfile","text":"read_torfile(torfile::AbstractString)\n\nReturn a vector of TorObj objects found in a TOR file\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.sor_efficiency-Tuple{String}","page":"API Reference","title":"TicraUtilities.sor_efficiency","text":"sor_efficiency(cut; F, D, Oc, pol=:matched, dz=0.0) -> (;ηₗₒₛₛ, ηₛₚ, ηᵢₗ, ηₚₕ, ηₚₒₗ, ηₓ)\n\nCompute boresight directivity efficiency of a parabolic single-offset reflector using the feed pattern specified by cut.\n\nPositional input arguments:\n\ncut: Either a string containing the name of a Ticra-compatible, spherical, polar, asymmetric cut file, or a Cut object as returned by the read_cutfile function.\n\nKeyword input arguments:\n\nF, D, and Oc:  The single-offset reflector focal length, aperture diameter, and center offset, respectively.  These may be expressed in any convenient length units, so  long as they are consistent. \npol: A Symbol having one of the values :L3h, :L3v, :RHCP, :LHCP, or :max (any variations in terms of capitalization are acceptable).  The first two denote Ludwig 3  horizontal (x) and vertical (y) polarizations, the second two denote the two senses of  circular polarization, and :max (the default) uses the polarization among the 4 previously listed that that has the maximum field amplitude.  Polarization efficiency and boresight polarization mismatch of the secondary pattern will be computed relative to the polarization specified by  this argument.  Note that for CP, this will be orthogonal to the primary copol.\ndz: This is a signed distance along the zfeed direction, measured in wavelengths. It allows for repositioning the feed in an attempt to locate the feed phase center at the reflector focal point. Suppose that the feed's phase center is located 0.42 wavelengths inside the horn aperture. The horn origin should ideally be positioned closer to the reflector, so a positive value dz = 0.42 would be specified to indicate that the horn has been repositioned in this manner.  \n\nReturn value:  A NamedTuple with the following fields:\n\n;ηₗₒₛₛ, ηₛₚ, ηᵢₗ, ηₚₕ, ηₚₒₗ, ηₓ\n\nηₗₒₛₛ: Feed loss efficiency (ratio of radiated power to 4π).\nηₛₚ: Spillover efficiency (a real number between 0 and 1).\nηᵢₗ: Illumination (amplitude taper) efficiency (a real number between 0 and 1).\nηₚₕ:  Phase error efficiency (a real number between 0 and 1).\nηₚₒₗ: Polarization efficiency (a real number between 0 and 1).\nηₓ: Boresight polarization mismatch loss efficiency (a real number between 0 and 1)\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.sph2cut-Tuple{AbstractString}","page":"API Reference","title":"TicraUtilities.sph2cut","text":"sph2cut(sphfile::AbstractString; theta, phi, ipol) -> cut::Cut\n\nsph2cut(sph:SPHQPartition; theta, phi, ipol) -> cut::Cut\n\nsph2cut(sphs:Vector{SPHQPartition}; theta, phi, ipol) -> cuts::Vector{Cut}\n\nConvert a set of Q-type spherical wave modal coefficients to far-field electric field  values, returned as a Cut object. \n\nThe single positional input argument can be either a string containing the name  of a Ticra-compatible Q-type spherical wave file, or the returned value from reading  such a file with read_sphfile.\n\nOptional Keyword Arguments:\n\ntheta: An abstract range denoting the desired polar angles (colattitudes)  in degrees at which the field should be evaluated. If an empty range is provided (the default), then the values will be determined automatically by examining the modal content in sph.\nphi: An abstract range denoting the desired azimuthal angles in degrees at  which the field should be evaluated.  If an empty range is provided (the default), then the values will be determined automatically by examining the modal content in sph.\nipol:  An integer in the range 0:3 denoting the desired polarization decomposition  for the computed field values. The meanings of these values are:\n0: (Default value) Choose the basis among choices 2 or 3 that produces the largest peak copol magnitude.\n1: Use a (θ̂, ϕ̂) basis.\n2: Use a (R̂, L̂) (i.e., circular polarization) basis.\n3: Use a (ĥ, v̂) (Ludwig 3) basis.\n\nUsage Example\n\ncut = sph2cut(\"testfile.sph\"; phi=0:5:355, theta=0:1:180, ipol=2)\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.sym2asym-Union{Tuple{Cut{Tt, Tp, N}}, Tuple{N}, Tuple{Tp}, Tuple{Tt}} where {Tt<:AbstractRange, Tp<:AbstractRange, N}","page":"API Reference","title":"TicraUtilities.sym2asym","text":"sym2asym(cut::Cut) -> cut2\n\nConvert a symmetrical (in θ) Cut to a new asymmetrical Cut.  An asymmetrical cut begins at θ = 0, while a symmetrical cut covers equal extents of negative and  positive angles.  If the input cut is already asymmetrical, then return a copy of  this input as the output.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.symsqueeze-Union{Tuple{Cut{T1, T2, N}}, Tuple{N}, Tuple{T2}, Tuple{T1}} where {T1<:AbstractRange, T2<:AbstractRange, N}","page":"API Reference","title":"TicraUtilities.symsqueeze","text":"symsqueeze(cut::Cut) -> cut2::Cut\n\nSqueeze a symmetric cut with ϕ values equally distributed in [0,360) into [0, 180).\n\nThe ϕ values must define nonredundant cuts.  I.e., cut.phi must be equivalent to the vector [0, Δϕ, 2Δϕ, 3Δϕ, ..., (360 - Δϕ)], with length(cut.phi) being an odd number, so that 180 is excluded.\n\ncut2 will have Δϕ/2 as its ϕ increment, and it's maximum ϕ value will be 180 - Δϕ/2.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.tepp2s-Tuple{TEPperiodic, Unitful.Quantity{<:Real, 𝐋}}","page":"API Reference","title":"TicraUtilities.tepp2s","text":"tepp2s(tep::TEPperiodic, d; title=\"\")\n\nConvert a periodic unit cell TEP object (of type TEPperiodic) to a scattering surface TEP object (of type TEPscatter), or to a vector of such objects if tep contains more than a single frequency.\n\nd is the is the distance between the front and rear reference planes, a Unitful length quantity.  The title keyword argument is used for the title field of the output object. If it is left at its default empty value, then it will be  replaced by \"TEPscatter object created by tepp2s\".\n\nUsage Example\n\nusing Unitful: @u_str\nd = 2.3u\"mm\"\ntep_scatter = tepp2s(tep_periodic, d)\n\nExtended help\n\nInput argument d is required because TEPperiodic uses phase reference planes located at the actual front and rear  surfaces of the unit cell, while TEPscatter uses the front surface only as the phase reference plane for both front and rear incidence.  Thus d is required to compute the necessary phase correction for rear surface incidence reflection and  for both front and rear surface incidence transmission.  This phase correction is in addition to sign changes needed for  some of the coefficients.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.teps2p","page":"API Reference","title":"TicraUtilities.teps2p","text":"teps2p(tep::TEPscatter, d, freq; name=\"tep_periodic\", class=\"created_by_teps2p\")\n\nConvert a scattering TEP object (of type TEPscatter) to a periodic unit cell TEP object (of type TEPperiodic).\n\nd is the is the distance between the front and rear reference  planes, a Unitful quantity. freq is the frequency, also a Unitful quantity.   tep and freq may be both scalars or both vectors of the same length.   In the latter case, each entry corresponds to a specific frequency.\n\nUsage Example\n\nusing Unitful: @u_str\nfreqs = [1.2u\"GHz\", 2u\"GHz\"] # Assumes teps is a vector of 2 TEPscatter objects\nd = 2.3u\"mm\"\ntep_periodic = teps2p(teps, d, freqs)\n\nExtended help\n\nInput argument freq is required because the frequencies are part of the data stored in a TEPperiodic object, but not in a TEPscatter object.  Additionally, both freq and d arguments are required because TEPperiodic uses phase reference  planes located at the actual front and rear surfaces of the unit cell, while TEPscatter uses the front surface only as the phase reference plane for both front and rear incidence.  Thus, these arguments are required to compute the necessary phase correction for rear surface incidence reflection and for both front and rear surface incidence transmission.   This phase correction is in addition to sign changes needed for some of the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#TicraUtilities.write_cutfile-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{AbstractString, Cut{T1, T2, N}}, Tuple{AbstractString, Cut{T1, T2, N}, String}} where {T1<:AbstractRange, T2<:AbstractRange, N}","page":"API Reference","title":"TicraUtilities.write_cutfile","text":"write_cutfile(fname::AbstractString, cut::Cut, title::AbstractString=\"Cut file created by write_cutfile\")\n\nwrite_cutfile(fname::AbstractString, cuts::AbstractVector{Cut}, title::AbstractString=\"Cut file created by write_cutfile\")\n\nWrite Cut cut data to a Ticra-compatible cut file.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.write_exifile-Tuple{AbstractString, Exi}","page":"API Reference","title":"TicraUtilities.write_exifile","text":"write_exifile(filename::AbstractString, t::Exi)\n\nCreate a Ticra-compatible excitation file from a Exi object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.write_sphfile-Tuple{AbstractString, Vector{SPHQPartition}}","page":"API Reference","title":"TicraUtilities.write_sphfile","text":"write_sphfile(fname, qs::Vector{SPHQPartition})\nwrite_sphfile(fname, qs::SPHQPartition)\n\nWrite SPH coefficients to a Q-type spherical wave expansion file.\n\nPrior to writing the data into the file, the input coefficients (Q) are conjugated and then multiplied by the factor 1/sqrt(8π) to become Q′ and achieve consistency with Ticra-standard normalization.  \n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.write_stationfile-Tuple{AbstractString, AbstractVector{Station}}","page":"API Reference","title":"TicraUtilities.write_stationfile","text":"write_stationfile(stationfile::AbstractString, stdat::Station)\nwrite_stationfile(stationfile::AbstractString, stdat::AbstractVector{Station})\n\nWrite a Ticra POS4-compatible optimization station file.  Here, when stdat is a vector, its elements are the partitions in the station file. \n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.write_surface-Tuple{AbstractString, Surface}","page":"API Reference","title":"TicraUtilities.write_surface","text":"write_surface(fname::AbstractString, sfc::Surface)\n\nWrite a Surface object to a Ticra-compatible surface file.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#TicraUtilities.write_tepfile","page":"API Reference","title":"TicraUtilities.write_tepfile","text":"write_tepfile(filename::AbstractString, tep::TEP)\nwrite_tepfile(filename::AbstractString, tep::Vector{TEPscatter})\n\nWrite a TICRA-compatible \"Tabulated Electrical Properties\" (TEP) file.  If type(tep) == TEPscatter or type(tep) == Vector{TEPscatter}, then the file will be written in the original format  (scattering surface) introduced by GRASP8. If type(tep) == TEPperiodic then the file will be written  in the newer format for periodic unit cells introduced by the QUPES program.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#TicraUtilities.write_torfile-Tuple{AbstractString, Vector{TorObj}}","page":"API Reference","title":"TicraUtilities.write_torfile","text":"write_torfile(fname::AbstractString, obj::TorObj; modestr = \"w\")\nwrite_torfile(fname::AbstractString, objs::Vector{TorObj}; modestr = \"w\")\n\nWrite one or multiple TorObj objects to a Ticra-compatible TOR (Ticra Object Repository) file. With the default value of modestr = \"w\", the file is created if it doesn't already exist, or, if it  already exists, it is truncated to zero length before writing the TOR object(s). By setting the value of modestr to \"a\" one can append the object(s) to an existing file.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Publicly-Exported-Types","page":"API Reference","title":"Publicly Exported Types","text":"","category":"section"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"Modules = [TicraUtilities]\nOrder   = [:type]\nPrivate = false","category":"page"},{"location":"autodocs/#TicraUtilities.Cut","page":"API Reference","title":"TicraUtilities.Cut","text":"Cut\n\nContains data for a Ticra \"Tabulated Pattern Data\" object. Note that a single Cut instance  contains all of the cuts for a single frequency.\n\nFields\n\nncomp::Int: Number of polarization components (2 or 3)\nicut::Int: 1 for standard constant ϕ polar cuts, 2 for conical, constant θ cuts.\nicomp::Int: Polarization control parameter. 1 for Eθ and Eφ, 2 for RHCP and LHCP, 3 for Co and Cx (Ludwig 3).\ntext::Vector{String}: Identification text for each constant angle cut.\ntheta::Tt<:AbstractRange: The theta values (in degrees) stored in the cut.\nphi::Tp<:AbstractRange: The phi values (in degrees) stored in the cut.\nevec: Matrix of complex field vectors for the two or three polarization components.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#TicraUtilities.Exi","page":"API Reference","title":"TicraUtilities.Exi","text":"Exi\n\nContains data from a Ticra excitation file.\n\nFields\n\nheader::Vector{String}: Header strings. One element for each line of the header.\nampdb::Vector{Float64}: Excitation amplitudes in dB.\nphsdeg::Vector{Float64}: Excitation phases in degrees.\nid::Vector{String}: Excitation ID strings.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#TicraUtilities.SPHQPartition","page":"API Reference","title":"TicraUtilities.SPHQPartition","text":"SPHQPartition\n\nStruct containing all the data read from a Ticra-compatible Q-type SPH file for one frequency. The qsmns field contains the Q coefficients. It is indexed as qsmns[s,m,n] where s ∈ {1,2}, m ∈ -mmax:mmax,  n ∈ {1, ..., mmax}.  But not all entries are used.  The only possible nonzero entries are where  n ∈ {max(1, abs(m)), ..., nmax}.  Note that if the coefficients stored in the SPH files are Q', and the cofficients stored in a SPHQPartition instance are Q, then Q = sqrt(8π) * conj(Q'), as discussed in the File Formats section of the Ticra official documentation.\n\nFields\n\nprgtag::String: Program tag and time stamp, from the program that created the file.\nidstrg::String: Identification text.\nnthe::Int: Number of θ-samples over 360°. Must be even and ≥ 4. \nnphi::Int: Number of ϕ-samples over 360°. Must be ≥ 3. \nnmax::Int: Maximum value for polar index n in the SW expansion. 1 ≤ nmax ≤ nthe÷2.\nmmax::Int: Maximum value for azimuthal index |m| in the SW expansion. 0 ≤ mmax ≤ min((nphi-1)÷2, nmax).\nt4::String: Dummy string.\nt5::String: Dummy string.  If parsed, contains 5 real numbers.\nt6::String: Dummy string.  If parsed, contains 5 real numbers.\nt7::String: Dummy string.\nt8::String: Dummy string.\nqsmns::OffsetArray{ComplexF64, 3}: Contains the Q coefficients, assuming exp(jωt) time variation and using the Ticra normalization convention.  The array has axes (1:2, -mmax:mmax, 1:nmax), meaning that some of the entries (those with n < abs(m)) are always zero.\npowerms::OffsetArray{Float64, 1}: The vector has axes (0:mmax) and the mth element contains the total power (one-half the sum of the magnitude squared) of all modes with ±m as the m index.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#TicraUtilities.Station","page":"API Reference","title":"TicraUtilities.Station","text":"Station\n\nA struct that contains data for a single partition of a Ticra-compatible optimization station file.\n\nFields\n\nnpoint::Int: The number of stations in the partition.\nu::Vector{Float64}: A vector of length npoint containing the u values (unitless direction cosine along x)  of each of the optimization stations in the partition.\nv::Vector{Float64}: A vector of length npoint containing the v values (unitless direction cosine along y)  of each of the optimization stations in the partition.\ngoal::Vector{Float64}: A vector of length npoint containing the goal values in dB  for each of the optimization stations in the partition.\nweight::Vector{Float64}: A vector of length npoint containing the optimization weights for each of the optimization stations in the partition.\nipol::Vector{Int}: A vector of length npoint containing the polarization codes  for each of the stations in the partition. The codes have the following meanings:\n1:  Linear Ludwig 3 x (\"copol\") component.\n2:  Linear Ludwig 3 y (\"cxpol\") component.\n3:  RHCP component.\n4:  LHCP component.\n5:  Major axis of polarization ellipse.\n6:  Minor axis of polarization ellipse.\n7:  The ratio co/cx in dB.\n8:  The ratio cx/co in dB.\n9:  The ratio RHCP/LHCP in dB.\n10:  The ratio LHCP/RHCP in dB.\n11:  The ratio major/minor in dB.\n12:  The ratio minor/major in dB.\n13:  The total power 10*log₁₀(‖E⃗‖²) in dB.\nrot::Vector{Float64}: A vector of length npoint containing the rotation in degrees of linear polarization reference for each of the optimization stations.\natt::Vector{Float64}: A vector of length npoint containing the attenuation in dB ≥ 0  relative to the sub-satellite point.\nID::Vector{String}: A vector of length npoint containing the ID string for each of the optimization stations in the partition. May be empty.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#TicraUtilities.Surface","page":"API Reference","title":"TicraUtilities.Surface","text":"Surface\n\nStruct containing all the data read from a Ticra-compatible regular x-y grid surface file.\n\nFields\n\ntext::String: Descriptive string.\nidstrg::String: Identification text.\nx::AbstractRange: The x coordinates at which the surface is sampled.\ny::AbstractRange: The y coordinates at which the surface is sampled.\nz::Matrix{Float64}:  z[i,j] contains the surface z-coordinate sampled at x = x[i] and y = y[j].\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#TicraUtilities.TEPperiodic","page":"API Reference","title":"TicraUtilities.TEPperiodic","text":"TEPperiodic <: TEP\n\nStruct containing the data from a TICRA-compatible  Tabulated Electrical Properties (TEP) file for a periodic unit cell.  Note that  TEP files containing geometrical parameter sweeps are not yet supported.\n\nFields\n\nname::String: Object name of the periodic unit cell.\nclass::String: Class name of the periodic unit cell.\ntheta: An AbstractRange containing the θ values in units specified by field atunit.\nphi: An AbstractRange containing the ϕ values in units specified by field atunit..\nfreqs: A vector of frequencies, each element of which is a Unitful quantity. The elements  may or may not all share the same frequency units.\nsff::Array{ComplexF64, 5}: Contains reflection coefficients for front surface incidence. \nsfr::Array{ComplexF64, 5}: Contains transmission coefficients for rear surface incidence. \nsrf::Array{ComplexF64, 5}: Contains transmission coefficients for front surface incidence. \nsrr::Array{ComplexF64, 5}: Contains reflection coefficients for rear surface incidence. \n\nFor s representing any of the fields sff, sfr, srf, and srr,  size(s) = (2, 2, length(theta), length(phi), length(freqs)), and the 2×2 matrix s[:,:,i,j,k]  is arranged in the order [sTETE sTETM; sTMTE sTMTM].\n\nSee Also\n\nTEPscatter\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#TicraUtilities.TEPscatter","page":"API Reference","title":"TicraUtilities.TEPscatter","text":"TEPscatter <: TEP\n\nStruct containing the data for a single frequency from a TICRA-compatible  Tabulated Electrical Properties (TEP) file for a scattering surface (i.e., the old-style, original definition of TEP file in use since GRASP8.)\n\nFields\n\ntitle::String: Contains the title string.\ntheta: An AbstractRange containing the θ values in degrees.\nphi: An AbstractRange containing the ϕ values in degrees.\nsff::Array{ComplexF64, 4}: Contains reflection coefficients for front surface incidence. \nsfr::Array{ComplexF64, 4}: Contains transmission coefficients for rear surface incidence. \nsrf::Array{ComplexF64, 4}: Contains transmission coefficients for front surface incidence. \nsrr::Array{ComplexF64, 4}: Contains reflection coefficients for rear surface incidence. \n\nFor s representing any of the fields sff, sfr, srf, and srr,  size(s) = (2, 2, length(theta), length(phi)), and the 2×2 matrix s[:,:,i,j]  is arranged in the order [sθθ sθϕ; sϕθ sϕϕ].\n\nSee Also\n\nTEPperiodic\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#TicraUtilities.TorObj","page":"API Reference","title":"TicraUtilities.TorObj","text":"TorObj\n\nStruct containing a single, general, TOR object.\n\nFields\n\nname::String: The name of the TOR object. Example: \"my_rim\".\nobjtype::String: The type of the TOR object. Example: \"tabulatedrimxy\".\npropname::Vector{String}: Names of object properties. Example:  [\"filename\", \"unit\", \"numberofpoints\", \"translation\", \"polarorigin\"]\npropval::Vector{String}: Values of object properties corresponding to the names in propnames. Example: [\"h9mscalloped_rim.xyz\", \"in\", \"112\", \"struct(x: 0.0 in, y: 0.0 in)\",  \"struct(status: automatic, x: 0.0 in, y: 0.0 in)\"]\n\nNote that the \"values\" in propval are simply strings that must be parsed for any numeric values that might be present.\n\nSee Also\n\nparse_tor_struct\n\n\n\n\n\n","category":"type"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"autodocs/","page":"API Reference","title":"API Reference","text":"This page was generated using Literate.jl.","category":"page"}]
}
